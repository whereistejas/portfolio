---
import "../styles/global.css";

import Page from "../layouts/page.astro";

import Row from "../components/row.astro";
import Textorlink from "../components/textorlink.astro";

const apiToken: string = "FniVXl7lBu5esBwjW47jhapfdqvo95st7q81dXEcDM1935dTJU";

/**
 * Represents the simplified shape you want for each Reader document.
 */
type Item = {
  url: URL;
  last_moved_at: Date;
  title: string;
  summary: string;
};

/**
 * Options for fetching documents from Readwise Reader.
 * You can omit or add more based on the API docs:
 * https://readwise.io/api/v3/list/
 */
interface FetchReaderDocsOptions {
  token: string; // Your Readwise API token
  location?: string; // new, later, shortlist, archive, feed
  category?: string; // article, email, rss, highlight, note, pdf, epub, tweet, video
  updatedAfter?: string; // Must be an ISO8601 date string (e.g. "2023-01-15T00:00:00Z")
  withHtmlContent?: boolean; // Whether or not to include HTML content
  // Add others if needed, e.g. "id"
}

/**
 * Fetches ALL documents (by following pagination) from the Readwise Reader "/api/v3/list/" endpoint,
 * and returns them in a simplified array of type `Item`.
 */
async function fetchAllReadwiseReaderItems(
  options: FetchReaderDocsOptions
): Promise<Item[]> {
  const { token, location, category, updatedAfter, withHtmlContent } = options;

  // Base URL for the endpoint
  const baseUrl = "https://readwise.io/api/v3/list/";

  // We'll store results here
  let items: Item[] = [];

  // Build query params for each request
  const url = new URL(baseUrl);
  // if (pageCursor) {
  //   url.searchParams.set("pageCursor", pageCursor);
  // }
  if (location) {
    url.searchParams.set("location", location);
  }
  if (category) {
    url.searchParams.set("category", category);
  }
  if (updatedAfter) {
    url.searchParams.set("updatedAfter", updatedAfter);
  }
  if (withHtmlContent != null) {
    url.searchParams.set("withHtmlContent", String(withHtmlContent));
  }

  // Make the request
  const response = await fetch(url.toString(), {
    headers: {
      Authorization: `Token ${token}`,
    },
  });

  if (!response.ok) {
    throw new Error(
      `Failed to fetch Reader items: ${response.status} ${response.statusText}`
    );
  }

  // The response contains { count, nextPageCursor, results }
  const data = await response.json();

  // If this endpoint returns `results` containing the actual docs
  // (as shown in the example JSON you provided)
  const docs = data.results ?? [];

  // Transform each doc into your desired `Item` shape
  for (const doc of docs) {
    items.push({
      url: new URL(doc.source_url),
      last_moved_at: new Date(doc.last_moved_at),
      title: doc.title,
      summary: doc.summary,
    });
  }

  items = items.sort(
    (a, b) => b.last_moved_at.getTime() - a.last_moved_at.getTime()
  );

  return items;
}

// Example usage:
let items = await fetchAllReadwiseReaderItems({
  token: apiToken,
  location: "archive",
});

const displayedDates = new Set<string>();

const headers = [
  { type: "text", content: "READING LIST" },
  { type: "text", content: "" },
  { type: "link", content: "CLOSE", href: "/" },
];
---

<Page>
  <Fragment slot="header">
    {
      headers.map((el) => (
        <Textorlink type={el.type} content={el.content} href={el.href} />
      ))
    }
  </Fragment>
  <Fragment slot="main">
    <section class="">
      <div
        class="w-full md:w-48 md:max-w-full
      flex flex-col justify-center gap-1"
      >
        {
          items.map((item) => {
            let dateStr = item.last_moved_at
              .toLocaleDateString("en-GB")
              .replace(/\//g, ".");
            if (!displayedDates.has(dateStr)) {
              displayedDates.add(dateStr);
            } else {
              dateStr = "";
            }
            return (
              <Row>
                <Fragment slot="key">{dateStr}</Fragment>
                <Fragment slot="value">
                  <p class="uppercase">
                    <a
                      href={item.url}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      {item.title}
                    </a>
                  </p>
                  <p class="pb-0.25">{item.summary}</p>
                </Fragment>
              </Row>
            );
          })
        }
      </div>
    </section>
  </Fragment>
</Page>
