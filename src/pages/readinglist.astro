---
import Page from "../layouts/page.astro";
import Row from "../components/row.astro";
import Textorlink from "../components/textorlink.astro";

const apiToken: string = "rCfuIkJtzCM4QJv5xuMyBLvtMmHv85rJ7dTwUm94k4eEgfM4vH";

// Node.js fs and path imports for server-side caching
let fs: typeof import("fs/promises") | undefined;
let path: typeof import("path") | undefined;
if (typeof window === "undefined") {
  fs = await import("fs/promises");
  path = await import("path");
}

/**
 * Represents the simplified shape you want for each Reader document.
 */
type Item = {
  url: string;
  last_moved_at: Date;
  title: string;
  summary: string;
};

/**
 * Options for fetching documents from Readwise Reader.
 * You can omit or add more based on the API docs:
 * https://readwise.io/api/v3/list/
 */
interface FetchReaderDocsOptions {
  token: string; // Your Readwise API token
  location?: string; // new, later, shortlist, archive, feed
  category?: string; // article, email, rss, highlight, note, pdf, epub, tweet, video
  updatedAfter?: string; // Must be an ISO8601 date string (e.g. "2023-01-15T00:00:00Z")
  withHtmlContent?: boolean; // Whether or not to include HTML content
  // Add others if needed, e.g. "id"
}

/**
 * Fetches ALL documents (by following pagination) from the Readwise Reader "/api/v3/list/" endpoint,
 * and returns them in a simplified array of type `Item`.
 */
async function fetchAllReadwiseReaderItems(
  options: FetchReaderDocsOptions
): Promise<Map<string, Item[]>> {
  const { token, location, category, updatedAfter, withHtmlContent } = options;

  // Base URL for the endpoint
  const baseUrl = "https://readwise.io/api/v3/list/";

  // We'll store results here
  const itemsMap: Map<string, Item[]> = new Map();

  // Build query params for each request
  const url = new URL(baseUrl);
  if (location) {
    url.searchParams.set("location", location);
  }
  if (category) {
    url.searchParams.set("category", category);
  }
  if (updatedAfter) {
    url.searchParams.set("updatedAfter", updatedAfter);
  }
  if (withHtmlContent != null) {
    url.searchParams.set("withHtmlContent", String(withHtmlContent));
  }

  // Make the request
  const response = await fetch(url.toString(), {
    headers: {
      Authorization: `Token ${token}`,
    },
  });

  if (!response.ok) {
    throw new Error(
      `Failed to fetch Reader items: ${response.status} ${response.statusText}`
    );
  }

  // The response contains { count, nextPageCursor, results }
  const data = await response.json();

  // If this endpoint returns `results` containing the actual docs
  const docs = data.results ?? [];

  // Transform each doc into your desired `Item` shape
  for (const doc of docs) {
    const item: Item = {
      url: new URL(doc.source_url).href,
      last_moved_at: new Date(doc.last_moved_at),
      title: doc.title,
      summary: doc.summary,
    };

    const dateStr = item.last_moved_at
      .toLocaleDateString("en-GB", {
        day: "2-digit",
        month: "short",
        year: "numeric",
      })
      .replace(/\//g, ".");

    if (!itemsMap.has(dateStr)) {
      itemsMap.set(dateStr, []);
    }
    itemsMap.get(dateStr)?.push(item);
  }

  // Sort the itemsMap by date in descending order
  const sortedItemsMap = new Map(
    [...itemsMap.entries()].sort((a, b) => {
      const dateA = new Date(a[0].split(".").reverse().join("-"));
      const dateB = new Date(b[0].split(".").reverse().join("-"));
      return dateB.getTime() - dateA.getTime();
    })
  );

  return sortedItemsMap;
}

// Try API first, then fallback to cache if API fails
let items: Map<string, Item[]>;
let usedCache = false;
try {
  items = await fetchAllReadwiseReaderItems({
    token: apiToken,
    location: "archive",
  });
  // If on server, save to cache for offline use
  if (typeof window === "undefined" && fs && path) {
    const cacheDir = path.resolve(process.cwd(), "tmp");
    const cacheFile = path.join(cacheDir, "readinglist.json");
    try {
      await fs.mkdir(cacheDir, { recursive: true });
      await fs.writeFile(
        cacheFile,
        JSON.stringify(Array.from(items.entries())),
        "utf-8"
      );
    } catch (e) {
      // Ignore cache write errors
    }
  }
} catch (err: any) {
  // If API fails, try to read from cache (server only)
  if (typeof window === "undefined" && fs && path) {
    const cacheDir = path.resolve(process.cwd(), "tmp");
    const cacheFile = path.join(cacheDir, "readinglist.json");
    try {
      const cacheData = await fs.readFile(cacheFile, "utf-8");
      const parsed: [string, Item[]][] = JSON.parse(cacheData);
      items = new Map(
        parsed.map(([date, arr]: [string, any[]]) => [
          date,
          arr.map((item: any) => ({
            ...item,
            last_moved_at: new Date(item.last_moved_at),
          })),
        ])
      );
      usedCache = true;
    } catch (cacheErr) {
      throw new Error("Failed to fetch from API and no cache available.");
    }
  } else {
    throw new Error(
      "Failed to fetch from API and cache is not available on client."
    );
  }
}

const displayedDates = new Set<string>();

const headers = [
  { type: "text", content: "READING LIST" },
  { type: "link", content: "CLOSE", href: "/" },
];
---

<Page title="Reading List">
  <Fragment slot="header">
    {
      headers.map((el) => (
        <Textorlink type={el.type} content={el.content} href={el.href} />
      ))
    }
  </Fragment>
  <Fragment slot="main">
    <div
      class="first:pt-2 first:md:pt-3 flex flex-col gap-2 md:gap-3 self-start"
    >
      <div class="columns-1 sm:columns-2 md:columns-3 gap-1.5">
        {
          Array.from(items.values())
            .flat()
            .sort(
              (a, b) => b.last_moved_at.getTime() - a.last_moved_at.getTime()
            )
            .map((item: Item) => (
              <div class="flex flex-col break-inside-avoid gap-0.25 pb-1.5">
                <a
                  href={item.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  class="font-semibold uppercase italic"
                >
                  <div class="text-pretty">{item.title}</div>
                </a>
                <span class="text-base text-neutral-500 dark:text-neutral-400">
                  {item.last_moved_at
                    .toLocaleDateString("en-GB", {
                      day: "2-digit",
                      month: "short",
                      year: "numeric",
                    })
                    .replace(/\//g, ".")}
                </span>
                <p class="leading-snug text-base font-normal hyphens-auto text-justify">
                  {item.summary}
                </p>
              </div>
            ))
        }
      </div>
    </div>
  </Fragment>
</Page>
